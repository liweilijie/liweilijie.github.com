<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>liwei.tk</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="李伟">
		<meta name="author" content="李伟的维基">

		<!-- Le styles -->
		<link href="assets/css/bootstrap.css" rel="stylesheet">
		<link href="assets/css/bootstrap-responsive.css" rel="stylesheet">
		<!-- display by liw for the padding at the top <link href="assets/css/docs.css" rel="stylesheet">-->
		<link href="assets/css/docs.css" rel="stylesheet">
		<link href="style.css" rel="stylesheet">
		<link href="assets/js/google-code-prettify/prettify.css" rel="stylesheet">

		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->

		<!-- Le fav and touch icons -->
		<link rel="shortcut icon" href="../assets/ico/favicon.ico">
		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="assets/ico/apple-touch-icon-144-precomposed.png">
		<link rel="apple-touch-icon-precomposed" sizes="114x114" href="assets/ico/apple-touch-icon-114-precomposed.png">
		<link rel="apple-touch-icon-precomposed" sizes="72x72" href="assets/ico/apple-touch-icon-72-precomposed.png">
		<link rel="apple-touch-icon-precomposed" href="assets/ico/apple-touch-icon-57-precomposed.png">

		<link type="text/css" rel="stylesheet" href="syntaxhighlighter/css/shCore.css" /> 
		<link type="text/css" rel="stylesheet" href="syntaxhighlighter/css/shThemeRDark.css" /> 
		<script type="text/javascript" src="syntaxhighlighter/js/shCore.js"></script> 
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushPython.js"></script>
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushBash.js"></script>
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushCpp.js"></script>
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushPowerShell.js"></script>
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushXml.js"></script>
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushPlain.js"></script>
		<script type="text/javascript" src="syntaxhighlighter/js/shBrushSql.js"></script>
		<script type="text/javascript">
			SyntaxHighlighter.defaults['gutter'] = true;
			SyntaxHighlighter.all();
			</script> 
			
<!-- add the google analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25233855-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

		</head>

		<body data-spy="scroll" data-target=".subnav" data-offset="50">

			<!--<div class="span10 well pricehover">-->

				<!-- ==================== start navbar ================== -->
				<div class="navbar">
					<div class="navbar-inner">
						<div class="container-fuid">
							<!-- old is : <div class="container"> and fixed by to 'fuid style' -->
								<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
									<span class="icon-bar"></span>
									<span class="icon-bar"></span>
									<span class="icon-bar"></span>
								</a>
								<a class="brand" href="#">Liwei.tk</a>
								<div class="nav-collapse">
									<ul class="nav">
										<li><a href="index.html">Home</a></li>
										<!-- Program sub projects  -->
										<li class="dropdown active">
										<a href="index.html#" class="dropdown-toggle" data-toggle="dropdown">Programs <b class="caret"></b></a>
										<ul class="dropdown-menu">
											<li><a href="c.html">C</a></li>
											<li><a href="cpp.html">Cpp</a></li>
											<li><a href="shell.html">Shell</a></li>
											<li class="divider"></li>
											<li class="nav-header">Others</li>
											<li><a href="python.html">Python</a></li>
											<li><a href="expect.html">Expect</a></li>
											<li><a href="vc.html">Vc</a></li>
										</ul>
										</li>
										<!-- Os sub projects  -->
										<li class="dropdown">
										<a href="index.html#" class="dropdown-toggle" data-toggle="dropdown">Os <b class="caret"></b></a>
										<ul class="dropdown-menu">
											<li><a href="linux.html">Linux</a></li>
											<li class="divider"></li>
											<li><a href="windows.html">Windows</a></li>
										</ul>
										</li>

										<!-- vim -->
										<li><a href="vim.html">Vim</a></li>
										<li><a href="#">Link</a></li>
										<li><a href="#">Link</a></li>
										<li class="dropdown">
										<a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
										<ul class="dropdown-menu">
											<li><a href="#">Action</a></li>
											<li><a href="#">Another action</a></li>
											<li><a href="#">Something else here</a></li>
											<li class="divider"></li>
											<li class="nav-header">Nav header</li>
											<li><a href="#">Separated link</a></li>
											<li><a href="#">One more separated link</a></li>
										</ul>
										</li>
									</ul>
									<form class="navbar-search pull-left" action="">
										<input type="text" class="search-query span2" placeholder="Search">
									</form>
									<ul class="nav pull-right">
										<li><a href="#">Link</a></li>
										<li class="divider-vertical"></li>
										<li class="dropdown">
										<a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <b class="caret"></b></a>
										<ul class="dropdown-menu">
											<li><a href="#">Action</a></li>
											<li><a href="#">Another action</a></li>
											<li><a href="#">Something else here</a></li>
											<li class="divider"></li>
											<li><a href="#">Separated link</a></li>
										</ul>
										</li>
									</ul>
								</div><!-- /.nav-collapse -->
							</div>
						</div><!-- /navbar-inner -->
					</div><!-- /navbar -->
					<!--</div>-->

				<div class="container">

					<!--span2 + span10 that's really content-->
					<div class="row">

						<!--left nav-->
						<div class="span3 side-nav">
							<div class="well sidebar-nav">
								<h3><a href="c.html">C</a></h3>

								<ul class="nav nav-pills nav-stacked">
									<li class="nav-header">关于语法</li>
									<li> <a href="c_cycle_single_link.html">单循环链表的实现</a></li>
									<li> <a href="c_util_function_interfaces.html">util function interface</a></li>
									<li> <a href="c_easy_error.html">只有两行的C程序至少有80%的人会判断错</a></li>
									<li> <a href="c_variable_length_array.html">c柔性数组</a></li>
									<li> <a href="c_counting_1_bits_c_implementations.html">计数一个整数中1的个数</a>
									<li> <a href="c_memory_manager_detail.html">c内存管理</a></li>
									<li> <a href="c_sscanf_detail.html">sscanf用法</a></li>
									<li> <a href="c_sizeof_about_point.html">sizeof(指针)</a><li>
									<li><a href="c_about_userlogin_api.html">c(api)实现用户登录信息</a></li>
									<li class="nav-header">常用实例</li>
									<li> <a href="c_debug_pthread_rwlock_t.html">compile时提示缺少pthread_rwlock_t类型定义</a></li> 
									<li> <a href="c_debug_memcmp_struct.html">小心使用memcmp来比较struct</a></li>
									<li> <a href="c_do_while_replase_if.html">用do...while(0)替代if多重判断</a></li>
									<li> <a href="c_gettimeofday_backup_time.html">c利用gettimeofday得到精确时间</a></li>
									<li> <a href="c_dynamic_two_dimensional_array.html">c动态申请二维数组</a></li>
									<li> <a href="c_program_analyse_deeply.html">c语言深度剖析</a></li>
									<li> <a href="c_macro_define_collect.html">c宏定义</a></li>
									<li> <a href="c_changable_agrument.html">c可变参数</a></li>
									<li class="nav-header">常用技巧</li>
									<li> <a href="c_function_argument.html">linux c 函数参考</a></li>
									<li> <a href="c_error.html">错误处理</a></li>
									<li> <a href="c_string.h.html">string.h 函数大全</a></li>
									<li> <a href="c_rand.html">c rand()</a></li>
									<li> <a href="c_diff_memcpy_memmove.html"> memcpy() memmove() 区别</a></li>
									<li> <a href="c_iconv_match_notice.html">慎用c语言中的iconv()</a></li>
								</ul>
							</div> <!-- ...well -->
						</div> <!-- --span  -->

						<!-- right contnet -->

						<div class="span9" data-spy="scroll" >
							<div class="gsearch"></div>
							<div class="content">
								<div class="alert top-nav"><a href="index.html">首页</a>&nbsp;&gt;&nbsp;<a href="c.html">C</a></div>
								
<h1>c内存管理</h1>
<div class="toc">
<ul>
<li><a href="#toc_0.1">序</a>
<li><a href="#toc_0.2">1、内存分配方式</a>
<li><a href="#toc_0.3">2、常见的内存错误及其对策</a>
<li><a href="#toc_0.4">3、指针与数组的对比</a>
<li><a href="#toc_0.5">4、指针参数是如何传递内存的？</a>
<li><a href="#toc_0.6">5、杜绝“野指针”</a>
<li><a href="#toc_0.7">6、有了malloc/free为什么还要new/delete？</a>
<li><a href="#toc_0.8">7、内存耗尽怎么办？</a>
<li><a href="#toc_0.9">8、malloc/free 的使用要点</a>
<li><a href="#toc_0.10">9、new/delete 的使用要点</a>
</ul>
</ul>
</div>

<h2 id="toc_0.1">序</h2>

<p>
<code>本文转自网络，根据个人的一些实例进行了汇总。</code>
</p>

<pre class="brush:bash">
伟大的Bill Gates 曾经失言：

　　程序员们经常编写内存管理程序，往往提心吊胆。
	如果不想触雷，唯一的解决办法就是发现所有潜伏的地雷并且排除它们，躲是躲不了的。
	本文的内容比一般教科书的要深入得多，读者需细心阅读，做到真正地通晓内存管理。
</pre>

<h2 id="toc_0.2">1、内存分配方式</h2>

<p>
在这之前，我想大家应该把程序在内存之中的布局弄明白，这里只是简要说明，大家最好看看apue上面的153页，写得很详细。
</p>

<p>
<a href="images/c_memory_manager_pic.jpg"><img src="images/c_memory_manager_pic.jpg" /></a>
</p>

<p>
<em>最高地址部分用于存放环境变量和主函数的入参</em>
</p>

<ul>
<li>
.data包含静态的和全局的已初始化的数据，

</ul>

<ul>
<li>
.bss包含静态的和全局的未初始化的数据。 

</ul>

<ul>
<li>
.text段包含程序指令和和很多只读数据。 

</ul>

<ul>
<li>
stack 包含局部的非静态的已初始化和未初始化的变量

</ul>

<ul>
<li>
heap 用于非配内存空间给malloc之类的函数

</ul>

<hr />

<p>
<strong>内存分配方式有三种：</strong> 
</p>

<p>
　　（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
</p>

<p>
　　（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
</p>

<p>
　　（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。
</p>

<h2 id="toc_0.3">2、常见的内存错误及其对策</h2>

<p>
　　发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。
	而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。
	有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下.
</p>

<ul>
<li>
<strong>内存分配未成功，却使用了它:</strong>

</ul>

<p>
　　当我们犯这种错误时，是因为我们没有意识到内存分配会不成功。
	常用解决办法是，在使用内存之前检查指针是否为 <strong>NULL</strong> 。如果指针p是函数的参数，那么在函数的入口处用 <strong>assert(p!=NULL)</strong> 进行
</p>

<p>
　　检查。如果是用malloc或new来申请内存，应该用 <strong>if(p==NULL)</strong>  或 <strong>if(p!=NULL)</strong> 进行防错处理。
</p>

<ul>
<li>
 <strong>内存分配虽然成功，但是尚未初始化就引用它:</strong>

</ul>

<p>
　　犯这种错误主要有两个起因：
	一是没有初始化的观念；
	二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。
</p>
	
<p>
	内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。
	所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。
</p>

<ul>
<li>
<strong>内存分配成功并且已经初始化，但操作越过了内存的边界:</strong>

</ul>

<p>
　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。
</p>

<ul>
<li>
<strong>忘记了释放内存，造成内存泄露:</strong>

</ul>

<p>
　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。
	终有一次程序突然死掉，系统出现提示：内存耗尽。
</p>

<p>
　　动态内存的申请与释放必须配对，程序中 <strong>malloc</strong> 与 <strong>free</strong> 的使用次数一定要相同，否则肯定有错误（ <strong>new/delete</strong> 同理）。
</p>

<ul>
<li>
<strong>释放了内存却继续使用它:</strong>

</ul>
<p>
　
</p>
<pre class="brush:plain">
　　有三种情况：

　　（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，
			此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。

　　（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，
			因为该内存在函数体结束时被自动销毁。

　　（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。
</pre>


<pre class="brush:plain">
　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。

　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。
</pre>

<h2 id="toc_0.4">3、指针与数组的对比</h2>

<p>
　　C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。
</p>

<p>
　　数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。
</p>

<p>
	数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。
</p>

<p>
　　指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。
</p>

<p>
　　下面以字符串为例比较指针与数组的特性。
</p>

<ul>
<li>
 <strong>修改内容</strong>

</ul>

<p>
　　示例中，字符数组a的容量是6个字符，其内容为hello。
	a的内容可以改变，如a[0]= 'X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。
	从语法上看，编译器并不觉得语句 p[0]= 'X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。
</p>

<pre class="brush:c">
char a[] = “hello”;
a[0] = 'X’;
cout &lt;&lt; a &lt;&lt; endl;
char *p = “world”; // 注意p指向常量字符串
p[0] = 'X’; // 编译器不能发现该错误
cout &lt;&lt; p &lt;&lt; endl;　　　　　　
</pre>

<ul>
<li>
<strong>内容复制与比较</strong>

</ul>

<p>
　　不能对数组名进行直接复制与比较。
	示例中，若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。
	应该用标准库函数strcpy进行复制。
	同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。
</p>

<p>
　　语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。
	要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，
	再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。
</p>

<pre class="brush:c">
// 数组…
char a[] = "hello";
char b[10];
strcpy(b, a); // 不能用 b = a;
if(strcmp(b, a) == 0) // 不能用 if (b == a)
…
// 指针…
int len = strlen(a);
char *p = (char *)malloc(sizeof(char)*(len+1));
strcpy(p,a); // 不要用 p = a;
if(strcmp(p, a) == 0) // 不要用 if (p == a)
</pre>

<ul>
<li>
<strong>计算内存容量</strong>

</ul>

<p>
　　用运算符sizeof可以计算出数组的容量（字节数）。
	示例中，sizeof(a)的值是12（注意别忘了’’）。指针p指向a，但是 sizeof(p)的值却是4。
	这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。 
	C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。
</p>

<p>
　　注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
	示例中，不论参数数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。
</p>

<pre class="brush:c">
char a[] = "hello world";
char *p = a;
cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节
cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节　　　　　示例3.3（a） 计算数组和指针的内存容量

void Func(char a[100])
{
　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节
}
</pre>


<h2 id="toc_0.5">4、指针参数是如何传递内存的？</h2>

<p>
　　如果函数的参数是一个指针，不要指望用该指针去申请动态内存。
	示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？
</p>

<pre class="brush:c">
void GetMemory(char *p, int num)
{
　p = (char *)malloc(sizeof(char) * num);
}
void Test(void)
{
　char *str = NULL;
　GetMemory(str, 100); // str 仍然为 NULL 
　strcpy(str, "hello"); // 运行错误
}
</pre>

<p>
　　毛病出在函数GetMemory中。
	编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。
	如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。
	在本例中，_p申请了新的内存，只是把 _p所指的内存地址改变了，
	但是p丝毫未变。所以函数GetMemory并不能输出任何东西。
	事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。
</p>

<p>
　　如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”.
</p>

<pre class="brush:c">
void GetMemory2(char **p, int num)
{
　*p = (char *)malloc(sizeof(char) * num);
}
void Test2(void)
{
　char *str = NULL;
　GetMemory2(&amp;str, 100); // 注意参数是 &amp;str，而不是str
　strcpy(str, "hello"); 
　cout&lt;&lt; str &lt;&lt; endl;
　free(str); 
}　
</pre>

<p>
　　由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单.
</p>

<pre class="brush:c">
char *GetMemory3(int num)
{
　char *p = (char *)malloc(sizeof(char) * num);
　return p;
}
void Test3(void)
{
　char *str = NULL;
　str = GetMemory3(100); 
　strcpy(str, "hello");
　cout&lt;&lt; str &lt;&lt; endl;
　free(str); 
}
</pre>

<p>
　　用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。
	这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡。
</p>

<pre class="brush:c">
char *GetString(void)
{
　char p[] = "hello world";
　return p; // 编译器将提出警告
}
void Test4(void)
{
　char *str = NULL;
　str = GetString(); // str 的内容是垃圾
　cout&lt;&lt; str &lt;&lt; endl;
}
</pre>

<p>
　　用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。
</p>

<p>
如果将上面的例子改成这样会怎么样？
</p>

<pre class="brush:cpp">
char *GetString2(void)
{
　char *p = "hello world";
　return p;
}
void Test5(void)
{
　char *str = NULL;
　str = GetString2();
　cout&lt;&lt; str &lt;&lt; endl;
}
</pre>

<p>
　　运行虽然不会出错，但是函数GetString2的设计概念却是错误的。
	因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。
	无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。
</p>

<h2 id="toc_0.6">5、杜绝“野指针”</h2>

<p>
　　“野指针”不是NULL指针，是指向“垃圾”内存的指针。
</p>

<p>
	人们一般不会错用NULL指针，因为用if语句很容易判断。
	但是“野指针”是很危险的，if语句对它不起作用。
</p>
	
<p>
	“野指针”的成因主要有两种：
</p>

<p>
　　（1）指针变量没有被初始化。
		 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。 
		 所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。
		 例如:
</p>
<pre class="brush:c">
			char *p = NULL;
			char *str = (char *) malloc(100);
</pre>
			
<p>
　　（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。
</p>

<p>
　　（3）指针操作超越了变量的作用范围。这种情况让人防不胜防，示例程序如下：
</p>

<pre class="brush:cpp">
class A 
{ 
　public:
　　void Func(void){ cout &lt;&lt; “Func of class A” &lt;&lt; endl; }
};
void Test(void)
{
　A *p;
　{
　　A a;
　　p = &amp;a; // 注意 a 的生命期
　}
　p-&gt;Func(); // p是“野指针”
}
</pre>


<p>
　　函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。
	但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。
</p>

<h2 id="toc_0.7">6、有了malloc/free为什么还要new/delete？</h2>

<p>
　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
</p>

<p>
　　对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
</p>

<p>
　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意 new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理。
</p>

<pre class="brush:cpp">
class Obj
{
　public :
　　Obj(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; }
　　~Obj(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; }
　　void Initialize(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; }
　　void Destroy(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; }
};
void UseMallocFree(void)
{
　Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存
　a-&gt;Initialize(); // 初始化
　//…
　a-&gt;Destroy(); // 清除工作
　free(a); // 释放内存
}
void UseNewDelete(void)
{
　Obj *a = new Obj; // 申请动态内存并且初始化
　//…
　delete a; // 清除并且释放内存
}
</pre>

<p>
　　类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。
	函数UseMallocFree中，由于 malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成初始化与清除工作。
	函数 UseNewDelete则简单得多。
</p>

<p>
　　所以我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。
	由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。
</p>

<p>
　　既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？
	这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
</p>

<p>
　　如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。
	如果用delete释放“malloc申请的动态内存 ”，理论上讲程序不会出错，但是该程序的可读性很差。
	所以new/delete必须配对使用，malloc/free也一样。
</p>

<h2 id="toc_0.8">7、内存耗尽怎么办？</h2>

<p>
　　如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。
	通常有三种方式处理“内存耗尽”问题。
</p>

<p>
　　（1）判断指针是否为NULL，如果是则马上用return语句终止本函数。例如：
</p>

<pre class="brush:cpp">
void Func(void)
{
　A *a = new A;
　if(a == NULL)
　{
　　return;
　}
　…
}
</pre>
			
<p>
　　（2）判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。例如：
</p>

<pre class="brush:cpp">
void Func(void)
{
　A *a = new A;
　if(a == NULL)
　{
　　cout &lt;&lt; “Memory Exhausted” &lt;&lt; endl;
　　exit(1);
　}
　…
}
</pre>
			
<p>
　　（3）为new和malloc设置异常处理函数。
</p>

<p>
　　上述（1）（2）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式（1）就显得力不从心（释放内存很麻烦），应该用方式（2）来处理。
</p>

<p>
　　很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？”
</p>

<p>
　　不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。
	如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。
</p>

<p>
　　有一个很重要的现象要告诉大家。
	对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。	
</p>

<h2 id="toc_0.9">8、malloc/free 的使用要点</h2>

<p>
　　函数malloc的原型如下：
</p>

<pre class="brush:c">
void * malloc(size_t size);
</pre>
<p>
　　用malloc申请一块长度为length的整数类型的内存，程序如下：
</p>

<pre class="brush:c">
int *p = (int *) malloc(sizeof(int) * length);
</pre>

<p>
　　我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。
</p>

<ul>
<li>
malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void * 转换成所需要的指针类型。

</ul>

<ul>
<li>
malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试： 

</ul>

<pre class="brush:c">
cout &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;
cout &lt;&lt; sizeof(long) &lt;&lt; endl;
cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl;
cout &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; sizeof(double) &lt;&lt; endl;
cout &lt;&lt; sizeof(void *) &lt;&lt; endl;
</pre>

<p>
　　在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。
</p>

<ul>
<li>
函数free的原型如下：

</ul>

<pre class="brush:c">
void free( void * memblock );
</pre>
			
<p>
　　为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。
	如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。
</p>

<h2 id="toc_0.10">9、new/delete 的使用要点</h2>

<p>
　　运算符new使用起来要比函数malloc简单得多，例如：
</p>

<pre class="brush:c">
int *p1 = (int *)malloc(sizeof(int) * length);
int *p2 = new int[length];
</pre>
			
<p>
　　这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。例如
</p>

<pre class="brush:c">
class Obj
{
　public :
　　Obj(void); // 无参数的构造函数
　　Obj(int x); // 带一个参数的构造函数
　　…
}
void Test(void)
{
　Obj *a = new Obj;
　Obj *b = new Obj(1); // 初值为1
　…
　delete a;
　delete b;
}
</pre>
			
<p>
　　如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如
</p>

<pre class="brush:c">
Obj *objects = new Obj[100]; // 创建100个动态对象
　　不能写成

Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1
　　在用delete释放对象数组时，留意不要丢了符号'[]’。例如

delete []objects; // 正确的用法
delete objects; // 错误的用法
</pre>

<p>
　　后者相当于delete objects[0]，漏掉了另外99个对象。
</p>

							</div>
						</div>
					</div> <!-- really content end -->

					<div class="row footer">
						<hr />
						<a href="index.html">首页</a>
						<a href="about.html"> | 关于</a>
						<a href="links.html"> | 链接</a>
						<a href="contact.html"> | 链接</a>
					</div>

				</div>

				<!-- Le javascript ================================================== -->
				<!-- Placed at the end of the document so the pages load faster -->
				<!-- display by liw <script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>-->
				<!--<script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>-->
				<script src="assets/js/jquery.js"></script>
				<script src="assets/js/google-code-prettify/prettify.js"></script>
				<script src="assets/js/bootstrap-transition.js"></script>
				<script src="assets/js/bootstrap-alert.js"></script>
				<script src="assets/js/bootstrap-modal.js"></script>
				<script src="assets/js/bootstrap-dropdown.js"></script>
				<script src="assets/js/bootstrap-scrollspy.js"></script>
				<script src="assets/js/bootstrap-tab.js"></script>
				<script src="assets/js/bootstrap-tooltip.js"></script>
				<script src="assets/js/bootstrap-popover.js"></script>
				<script src="assets/js/bootstrap-button.js"></script>
				<script src="assets/js/bootstrap-collapse.js"></script>
				<script src="assets/js/bootstrap-carousel.js"></script>
				<script src="assets/js/bootstrap-typeahead.js"></script>
				<script src="assets/js/application.js"></script>
				<script src="assets/js/liwei.js"></script>


			</body>
		</html>
