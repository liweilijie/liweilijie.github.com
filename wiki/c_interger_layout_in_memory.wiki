%toc c语言中整数在内存中的格式
%title c语言中整数在内存中的格式
%template c

== 1. big endian 和 small endian ==

在intel机器上都是采用的small endian即小端字节序，也就是`地位的地址低，高位的地址高`。
{{{class="brush:c;"

int i = 0x12345678;
char c1 = *(char *)(&i)
}}}


一个int型整数的地址就是其最低位的地址，所以上例中c1的值就是  *0x78* . 

那么整数的正数，负数，以及无符号整数的表示方法有什么区别呢?

*对于正整数来说，内存里装的就是它自己的二进制码*

 
- 而负数呢，是对齐相应的整数，逐位求反，然后+1.

负数的最高位都是1，不是规定的，而是算出来的结果，最高位必为1.
根据上述算法-1 不是0x80000001 而是0xFFFFFFFF.

下面相应的介绍一下左移<<和右移>>的计算.
左移：


左移相对比较简单，是不考虑符号位的，符号位也会被移除，正数可能左移成负数，负数也可能编程正数

而右移呢，就需要考虑符号位了。右移过程中符号位保持不变，但注意符号位如果是1也是右移给右侧一位的，虽然自己不变。


上例的结果既不是0x40000000也不是0x00000000，居然是0xc0000000(1100 0000 0000 ....)

那么无符号有什么区别么？左移来说，没有任何区别，但对于右移来说，因为无符号整数表示最高位不是符号位，右移就可以移动了
所以0x80000000 >> 1 就是0x40000000了

利用上面的特点，我们可以很技巧的判断一个给定的子网掩码是不是合法的掩码，什么是合法的呢？就是从左开始一直是1，一旦遇到0后，后续的不能再有1的出现。



注意参数必须是int不能是unsigned int，因为要利用右移保留符号位的特性。
道理比较简单，就是子网掩码一定是1...10...0的格式，右移之后，1的个数会多一个，但是和原来的mask做&操作后还是mask，如果mask是非法的，0与0之间一定混有1，一旦 右移又与操作后，就会多出2个1，就会不等于原来的mask了

怎么求一个合法的掩码的位数呢？

http://blog.chinaunix.net/uid-23817499-id-3320671.html
